// Generated by CoffeeScript 1.4.0
(function() {
  var Account, Assignment, Course, L, async, colors, config, logger, logging, models, moment;

  async = require("async");

  colors = require("colors");

  moment = require("moment");

  config = require("./config");

  models = require("./models");

  logging = require("./logging");

  Account = models.Account;

  Course = models.Course;

  Assignment = models.Assignment;

  logger = new logging.Logger("API");

  L = function(prefix, message, urgency) {
    if (urgency == null) {
      urgency = "debug";
    }
    return logger[urgency]("" + prefix.underline + " :: " + message);
  };

  module.exports = {
    _create_account: function(username, cb) {
      var account,
        _this = this;
      account = new Account();
      account._id = username;
      account.nickname = "TestAccount";
      return account.save(function(err, doc) {
        if (err) {
          return cb(err);
        }
        return cb(null, {
          account: doc,
          token: {
            cookie: "1235TESTCOOKIE54321",
            username: doc._id
          }
        });
      });
    },
    read_settings: function(token, cb) {
      return Account.findOne().where('_id', token.username).select('nickname details is_new firstrun updated migrate').exec(cb);
    },
    update_settings: function(token, settings, cb) {
      return Account.update({
        _id: token.username
      }, {
        nickname: settings.nickname,
        details: settings.details,
        firstrun: settings.firstrun,
        migrate: settings.migrate
      }, cb);
    },
    _delete_account: function(token, account, cb) {
      return async.parallel([
        function(callback) {
          return Account.where('_id', account).remove(callback);
        }, function(callback) {
          return Course.where('owner', account).remove(callback);
        }, function(callback) {
          return Assignment.where('owner', account).remove(callback);
        }
      ], cb);
    },
    migrate: function(token, nuke, cb) {
      var finish;
      finish = function() {
        return Account.update({
          _id: token.username
        }, {
          migrate: false
        }, cb);
      };
      if (nuke) {
        return async.parallel([
          function(callback) {
            return Course.where('owner', token.username).remove(callback);
          }, function(callback) {
            return Assignment.where('owner', token.username).remove(callback);
          }
        ], finish);
      } else {
        return finish();
      }
    },
    by_course: function(token, cb) {
      var _this = this;
      return Course.where('owner', token.username).populate('assignments', 'title archived details date done jbha_id').select('-owner -jbha_id').exec(function(err, courses) {
        if (err) {
          return cb(err);
        }
        return cb(err, courses);
      });
    },
    create_assignment: function(token, data, cb) {
      return async.waterfall([
        function(wf_callback) {
          return Course.findById(data.course).exec(wf_callback);
        }, function(course, wf_callback) {
          var assignment;
          assignment = new Assignment();
          assignment.owner = token.username;
          assignment.title = data.title;
          assignment.date = data.date;
          assignment.details = data.details;
          return assignment.save(function(err) {
            return wf_callback(err, course, assignment);
          });
        }, function(course, assignment, wf_callback) {
          course.assignments.addToSet(assignment);
          return course.save(function(err) {
            return wf_callback(err, course, assignment);
          });
        }
      ], function(err, course, assignment) {
        return cb(err, course, assignment);
      });
    },
    update_assignment: function(token, assignment, cb) {
      return async.waterfall([
        function(wf_callback) {
          return Course.update({
            owner: token.username,
            assignments: assignment._id
          }, {
            $pull: {
              assignments: assignment._id
            }
          }, {}, wf_callback);
        }, function(wf_callback) {
          return Course.findOne().where('owner', token.username).where('_id', assignment.course).exec(wf_callback);
        }, function(course, wf_callback) {
          course.assignments.addToSet(assignment._id);
          return course.save(wf_callback);
        }
      ], function(err) {
        if (err) {
          return cb(err);
        }
        return Assignment.update({
          owner: token.username,
          _id: assignment._id
        }, {
          title: assignment.title,
          date: assignment.date,
          details: assignment.details,
          done: assignment.done,
          archived: assignment.archived
        }, {}, cb);
      });
    },
    delete_assignment: function(token, assignment, cb) {
      return Assignment.where('owner', token.username).where('_id', assignment._id).remove(cb);
    },
    create_course: function(token, data, cb) {
      var course;
      course = new Course();
      course.owner = token.username;
      course.title = data.title;
      course.teacher = data.teacher;
      return course.save(cb);
    },
    update_course: function(token, course, cb) {
      return Course.update({
        owner: token.username,
        _id: course._id
      }, {
        title: course.title,
        teacher: course.teacher
      }, function(err, numAffected, raw) {
        return cb(err);
      });
    },
    delete_course: function(token, course, cb) {
      return Course.where('owner', token.username).where('_id', course._id).remove(cb);
    },
    suppress_logging: function() {
      return L = function() {};
    }
  };

}).call(this);
